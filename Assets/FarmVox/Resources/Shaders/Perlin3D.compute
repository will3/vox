// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "noise.cginc"

RWStructuredBuffer<float> _Results;
int _Size;
int _Seed;
float _Frequency;
float _Lacunarity;
float _Persistence;
int _Octaves;
float3 _Origin;
float _YScale;
float _XZScale;
float _Amplitude;
int _DataSize;
int _Type;
float _Offset;

// fractal sum, range -1.0 - 1.0
float fBm(float3 p, int octaves)
{
    float freq = _Frequency;
    float amp = 0.5;
    float sum = 0;
    for(int i = 0; i < octaves; i++) 
    {
        sum += snoise(p * freq) * amp;
        freq *= _Lacunarity;
        amp *= _Persistence;
    }
    return sum;
}

// fractal abs sum, range 0.0 - 1.0
float turbulence(float3 p, int octaves)
{
    float sum = 0;
    float freq = _Frequency;
    float amp = 1.0;
    for(int i = 0; i < octaves; i++) 
    {
        sum += abs(snoise(p*freq))*amp;
        freq *= _Lacunarity;
        amp *= _Persistence;
    }
    return sum;
}

// Ridged multifractal, range 0.0 - 1.0
// See "Texturing & Modeling, A Procedural Approach", Chapter 12
float ridge(float h, float offset)
{
    h = abs(h);
    h = offset - h;
    h = h * h;
    return h;
}

float ridgedmf(float3 p, int octaves, float offset)
{
    float sum = 0;
    float freq = _Frequency;
    float amp = 0.5;
    float prev = 1.0;
    for(int i = 0; i < octaves; i++) 
    {
        float n = ridge(snoise(p*freq), offset);
        sum += n*amp*prev;
        prev = n;
        freq *= _Lacunarity;
        amp *= _Persistence;
    }
    return sum;
}

int getIndex(int i, int j, int k) {
    return i * _DataSize * _DataSize + j * _DataSize + k;
}

[numthreads(8, 8, 4)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _DataSize || id.y >= _DataSize || id.z >= _DataSize) {
        return;
    }
    float3 c = _Origin + float3(id.x, id.y, id.z);
    c.y *= _YScale;
    c.xz *= _XZScale;

    c.z += _Seed % 1000000;

    float offset = 1.0f;
    float value;
    if (_Type == 0) {
        value = fBm(c, _Octaves);
    } else if (_Type == 1) {
        value = ridgedmf(c, _Octaves, offset);
    } else if (_Type == 2) {
        value = turbulence(c, _Octaves);
    }

    int index = getIndex(id.x, id.y, id.z);
    
    value = value * _Amplitude + _Offset;
    
    _Results[index] = value;
}