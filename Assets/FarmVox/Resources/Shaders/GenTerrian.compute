// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "common.cginc"

StructuredBuffer<float> _HeightBuffer;
StructuredBuffer<float> _RockColorBuffer;
StructuredBuffer<float> _GrassBuffer;
StructuredBuffer<float> _StoneBuffer;
StructuredBuffer<float> _EdgeBuffer;

float _MaxHeight;
int _WaterLevel;

float _HillHeight;
float _GroundHeight;

// Rock color
float4 _RockGradient[8];
float _RockGradientIntervals[8];
float _RockGradientBanding;
int _RockGradientSize;

// Grass color
float4 _GrassGradient[8];
float _GrassGradientIntervals[8];
float _GrassGradientBanding;
int _GrassGradientSize;

// Grass color
float4 _StoneGradient[8];
float _StoneGradientIntervals[8];
float _StoneGradientBanding;
int _StoneGradientSize;

// Grass Normal Filter
float _GrassNormalValues[8];
float _GrassNormalKeys[8];
int _GrassNormalSize;

// Grass Height Filter
float _GrassHeightValues[8];
float _GrassHeightKeys[8];
int _GrassHeightSize;
float _GrassValue;

// Height Filter
float _HeightValues[8];
float _HeightKeys[8];
int _HeightSize;

// Stone Height Filter
float _StoneHeightValues[8];
float _StoneHeightKeys[8];
int _StoneHeightSize;
float _StoneValue;

// Edge
float _EdgeValues[8];
float _EdgeKeys[8];
int _EdgeSize;

float _EdgeDistance;

// Output
RWStructuredBuffer<float> _VoxelBuffer;
RWStructuredBuffer<float4> _ColorBuffer;

int _Size;
float3 _Origin;
int _DataSize;
int _Resolution;
int4 _Bounds;

int getIndex(int3 coord) {
    int dataSize = _DataSize;
    return (coord.x * dataSize * dataSize) + (coord.y * dataSize) + coord.z;
}

float readBuffer(StructuredBuffer<float> buffer, int3 coord) {
    int index = coord.x * _DataSize * _DataSize + coord.y * _DataSize + coord.z;
    return buffer[index];
}

float getVoxel(int3 coord) {
    int index = getIndex(coord);
    float v = _VoxelBuffer[index];
    return v;
}

float getGrassDot(int i, int j, int k) {
    float v = getVoxel(int3(i, j, k));

    if (v <= 0) {
        return 99;
    }
    
    float v1 = getVoxel(int3(i + 1, j, k));
    float v2 = getVoxel(int3(i - 1, j, k));
    float v3 = getVoxel(int3(i, j + 1, k));
    float v4 = getVoxel(int3(i, j - 1, k));
    float v5 = getVoxel(int3(i, j, k + 1));
    float v6 = getVoxel(int3(i, j, k - 1));
    
    if (v1 > 0 && v2 > 0 && v3 > 0 && v4 > 0 && v5 > 0 && v6 > 0) {
        return 99;
    }

    float3 d =  float3(1, 0, 0) * v1 +
    float3(-1, 0, 0) * v2   +
    float3(0, 1, 0) * v3    +
    float3(0, -1, 0) * v4   +
    float3(0, 0, 1) * v5    +
    float3(0, 0, -1) * v6;
    
    float3 up = float3(0, 1, 0);
    return clamp(dot(-normalize(d), up), 0, 1);
}

float getGrass(int3 coord, float heightRatio, int absY) {
    if (absY < _WaterLevel - 1) {
        return 0;
    }
    
    float normal = getGrassDot(coord.x, coord.y, coord.z);
    
    if (normal == 99) {
        return 0;
    }
    
    float normalValue = sampleValue(_GrassNormalValues, _GrassNormalKeys, _GrassNormalSize, normal);
    
    float heightValue = sampleValue(_GrassHeightValues, _GrassHeightKeys, _GrassHeightSize, heightRatio);
    
    return normalValue * heightValue - _GrassValue;
}

float getStone(int3 coord, float heightRatio) {
    int index = getIndex(coord);
    float heightValue = sampleValue(_StoneHeightValues, _StoneHeightKeys, _StoneHeightSize, heightRatio);
    float v = _StoneBuffer[index];
    return v * heightValue - 0.3;
}

float calcDistanceFromEdge(int3 worldCoord) {
    return min(
        min(worldCoord.x - _Bounds[0] - 1, worldCoord.z - _Bounds[1] - 1), 
        min(_Bounds[2] - worldCoord.x, _Bounds[3] - worldCoord.z));
}

float getHeight(int3 coord) {
    int3 worldCoord = coord + _Origin;
    float distanceFromEdge = calcDistanceFromEdge(worldCoord);
    float edgeRatio = clamp(1 - distanceFromEdge / _EdgeDistance, 0, 1);
    int index = getIndex(coord);
    float edgeValue = sampleValue(_EdgeValues, _EdgeKeys, _EdgeSize, edgeRatio) * clamp(_EdgeBuffer[index], 0, 1); 

    float relY = worldCoord.y - _GroundHeight;
    float gradient = -relY / _HillHeight;
    gradient += edgeValue; 

    return sampleValue(_HeightValues, _HeightKeys, _HeightSize, _HeightBuffer[index]) + gradient;
}

[numthreads(8, 8, 4)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int dataSize = _DataSize;
    if (id.x >= dataSize || id.y >= dataSize || id.z >= dataSize) {
        return;
    }

    int3 coord = int3(id.x, id.y, id.z);
    int index = getIndex(coord);
    
    int3 worldCoord = coord + _Origin;

    float height = getHeight(coord);
    _VoxelBuffer[index] = height;

    float heightRatio = worldCoord.y / _MaxHeight;
    float4 rockColor = sampleColor(_RockGradient, _RockGradientIntervals, _RockGradientSize, _RockGradientBanding, heightRatio + _RockColorBuffer[index]);
    float grass = getGrass(coord, heightRatio, worldCoord.y);
    float4 grassColor = sampleColor(_GrassGradient, _GrassGradientIntervals, _GrassGradientSize, _GrassGradientBanding, grass);
    
    float stone = getStone(coord, heightRatio);

    if (stone > 0) {
        float4 stoneColor = sampleColor(_StoneGradient, _StoneGradientIntervals, _StoneGradientSize, _StoneGradientBanding, stone);
        _ColorBuffer[index] = stoneColor;
    } else {
        if (grass > 0) {
            _ColorBuffer[index] = grassColor;
        } else {
            _ColorBuffer[index] = rockColor;
        }
    }
    
    float d = calcDistanceFromEdge(worldCoord);
    if (d < 3) {
        // _ColorBuffer[index] = float4(1, 0, 0, 1); 
    }
}
