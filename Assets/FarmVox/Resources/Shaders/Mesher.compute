// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Quad {
    float3 a;
    float3 b;
    float3 c;
    float3 d;
    float4 color;
    float4 ao;
    int3 coord;
    float3 normal;
};

// Input
StructuredBuffer<float> _VoxelBuffer;
StructuredBuffer<float4> _ColorsBuffer;
StructuredBuffer<float3> _NormalsBuffer;

// Output
AppendStructuredBuffer<Quad> _QuadsBuffer;

int _Size;
int _IsWater;
float _AoStrength;

int3 _Origin;
int _WaterLevel;
float _WaterOpacity;

int3 getVectorInt(int i, int j, int k, int d) {
    if (d == 0) {
        return int3(i, j, k);
    } else if (d == 1) {
        return int3(k, i, j);
    } 

    return int3(j, k, i);
}

float3 getVector(int i, int j, int k, int d) {
    if (d == 0) {
        return float3(i, j, k);
    } else if (d == 1) {
        return float3(k, i, j);
    } 

    return float3(j, k, i);
}

Quad buildQuad(float3 a, float3 b, float3 c, float3 d, float4 color, float4 ao, bool order, int3 coord, float3 normal) {
    Quad t;

    t.color = color;
    t.coord = coord;
    t.normal = normal;

    if (order) {
        t.a = a;
        t.b = b;
        t.c = c;
        t.d = d;
        t.ao = ao;
    } else {
        t.a = c;
        t.b = b;
        t.c = a;
        t.d = d;
        t.ao = float4(ao[2], ao[1], ao[0], ao[3]);
    }

    return t;
}

float calcAORaw(float s1f, float s2f, float cf) {
    bool s1 = s1f > 0;
    bool s2 = s2f > 0;
    bool c = cf > 0;

    if (s1 && s2) {
        return 1.0;
    }

    int count = 0;
    if (s1 > 0) count ++;
    if (s2 > 0) count ++;
    if (c > 0) count ++;

    if (count == 0) return 0.0;
    if (count == 1) return 0.33;
    return 0.66;
}

float calcAO(float s1f, float s2f, float cf, float aoStrength) {
    return 1.0 - (calcAORaw(s1f, s2f, cf) * aoStrength);
}

int getIndex(int3 coord) {
    return coord.x * _Size * _Size + coord.y * _Size + coord.z;
}

float getVoxel(int3 coord) {
    int index = getIndex(coord);
    if (index == -1) {
        return 0;
    }
    float v = _VoxelBuffer[index];
    return v;
}

float4 getColor(int3 coord) {
    int3 worldCoord = coord + _Origin;
    int index = getIndex(coord);
    if (index == -1) {
        return float4(1, 0, 0, 1);
    }

    float depthRatio = 1;
    if (!_IsWater && worldCoord.y < _WaterLevel) {
        int depth = _WaterLevel - worldCoord.y;
        depthRatio = pow(_WaterOpacity, depth - 1);
    }

    return _ColorsBuffer[index] * depthRatio;
}
       
void addQuadIfNeeded(int3 coord, int d) {
    int i = coord.x;
    int j = coord.y;
    int k = coord.z;

    int size = _Size;

    if (i == 0 || i >= size - 2 || j == 0 || j >= size - 2 || k == 0 || k >= size - 2) {
        return;
    }

    int3 coordA = getVectorInt(i, j, k, d);
    int3 coordB = getVectorInt(i + 1, j, k, d);

    float a = getVoxel(coordA);
    float b = getVoxel(coordB);

    bool front = a > 0;

    if (_IsWater && d != 1 && front) {
        return;
    }

    if (a > 0 == b > 0 )
    {
        return;
    }

    int3 c = front ? int3(i, j, k) : int3(i + 1, j, k);
    c = getVector(c.x, c.y, c.z, d);

    int index = getIndex(c);
    float3 normal = _NormalsBuffer[index];
  
    float4 color = getColor(c);

    int aoI = front ? i + 1 : i;
    float v00 = getVoxel(getVectorInt(aoI, j - 1, k - 1, d));
    float v01 = getVoxel(getVectorInt(aoI, j, k - 1, d));
    float v02 = getVoxel(getVectorInt(aoI, j + 1, k - 1, d));
    float v10 = getVoxel(getVectorInt(aoI, j - 1, k, d));
    float v12 = getVoxel(getVectorInt(aoI, j + 1, k, d));
    float v20 = getVoxel(getVectorInt(aoI, j - 1, k + 1, d));
    float v21 = getVoxel(getVectorInt(aoI, j, k + 1, d));
    float v22 = getVoxel(getVectorInt(aoI, j + 1, k + 1, d));

    float aoStrength = _AoStrength;
    float4 ao = float4(
        calcAO(v10, v01, v00, aoStrength),
        calcAO(v01, v12, v02, aoStrength),
        calcAO(v12, v21, v22, aoStrength),
        calcAO(v21, v10, v20, aoStrength));

    Quad quad = buildQuad(
        getVector(i + 1, j, k, d),
        getVector(i + 1, j + 1, k, d),
        getVector(i + 1, j + 1, k + 1, d),
        getVector(i + 1, j, k + 1, d),
        color,
        ao,
        front,
        c,
        normal
    );

    _QuadsBuffer.Append(quad);
}

void addQuadsIfNeeded(int3 coord) {
    for (int d = 0; d < 3; d++) {
        addQuadIfNeeded(coord, d);
    }
}

[numthreads(8, 8, 4)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int3 coord = int3(id.x, id.y, id.z);
    addQuadsIfNeeded(coord);
}