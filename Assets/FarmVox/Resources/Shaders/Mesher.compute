// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Quad {
    float3 a;
    float3 b;
    float3 c;
    float3 d;
    float4 color;
    float4 ao;
    int x;
    int y;
    int z;
    float3 normal;
};

// Input
StructuredBuffer<float> _VoxelBuffer;
StructuredBuffer<float4> _ColorsBuffer;

// Output
AppendStructuredBuffer<Quad> _QuadsBuffer;

int _Size;
float _NormalBanding;
int _IsWater;
float _AoStrength;

int3 _Origin;
int _WaterLevel;
float _WaterOpacity;

int3 getVectorInt(int i, int j, int k, int d) {
    if (d == 0) {
        return int3(i, j, k);
    } else if (d == 1) {
        return int3(k, i, j);
    } 

    return int3(j, k, i);
}

float3 getVector(int i, int j, int k, int d) {
    if (d == 0) {
        return float3(i, j, k);
    } else if (d == 1) {
        return float3(k, i, j);
    } 

    return float3(j, k, i);
}

int getIndex(int3 coord) {
    return coord.x * _Size * _Size + coord.y * _Size + coord.z;
}

float getVoxel(int3 coord) {
    int index = getIndex(coord);
    if (index == -1) {
        return 0;
    }
    float v = _VoxelBuffer[index];
    return v;
}

float3 calcNormal(int3 coord) {
    int i = coord.x;
    int j = coord.y;
    int k = coord.z;

    float3 v;
        for(int di = -1; di <= 1; di++) {
        for(int dj = -1; dj <= 1; dj++) {
        for(int dk = -1; dk <= 1; dk++) {
            v += normalize(float3(di,dj,dk)) * getVoxel(int3(i + di, j + dj, k + dk));
        }
        }
    }
    return normalize(v);
}

void addQuad(float3 a, float3 b, float3 c, float3 d, float4 color, float aa, float ab, float ac, float ad, bool order, int x, int y, int z, float3 normal) {
    Quad t;

    t.color = color;
    t.x = x;
    t.y = y;
    t.z = z;
    t.normal = normal;

    if (order) {
        t.a = a;
        t.b = b;
        t.c = c;
        t.d = d;
        t.ao = float4(aa, ab, ac, ad);
    } else {
        t.a = c;
        t.b = b;
        t.c = a;
        t.d = d;
        t.ao = float4(ac, ab, aa, ad);
    }

    _QuadsBuffer.Append(t);
}

float4 getColor(int3 coord) {
    int3 worldCoord = coord + _Origin;
    int index = getIndex(coord);
    if (index == -1) {
        return float4(1, 0, 0, 1);
    }
    
    float depthRatio = 1;
    if (!_IsWater && worldCoord.y < _WaterLevel) {
        int depth = _WaterLevel - worldCoord.y;
        depthRatio = pow(_WaterOpacity, depth - 1);
    }

    return _ColorsBuffer[index] * depthRatio;
}

float calcAORaw(float s1f, float s2f, float cf) {
    bool s1 = s1f > 0;
    bool s2 = s2f > 0;
    bool c = cf > 0;

    if (s1 && s2) {
        return 1.0;
    }

    int count = 0;
    if (s1 > 0) count ++;
    if (s2 > 0) count ++;
    if (c > 0) count ++;

    if (count == 0) return 0.0;
    if (count == 1) return 0.33;
    return 0.66;
}

float calcAO(float s1f, float s2f, float cf) {
    return 1.0 - (calcAORaw(s1f, s2f, cf) * _AoStrength);
}
       
void addQuadIfNeeded(int3 coord, int d) {
    int i = coord.x;
    int j = coord.y;
    int k = coord.z;

    int size = _Size;

    if (i == 0 || i >= size - 2 || j == 0 || j >= size - 2 || k == 0 || k >= size - 2) {
        return;
    }

    int3 coordA = getVectorInt(i, j, k, d);
    int3 coordB = getVectorInt(i + 1, j, k, d);

    float a = getVoxel(coordA);
    float b = getVoxel(coordB);

    bool front = a > 0;

    if (_IsWater && d != 1 && front) {
        return;
    }

    if (a > 0 == b > 0 )
    {
        return;
    }

    int3 c = front ? int3(i, j, k) : int3(i + 1, j, k);
    c = getVector(c.x, c.y, c.z, d);

    float3 normal = calcNormal(c);
  
    float4 color = getColor(c);

    int aoI = front ? i + 1 : i;
    int3 c00 = getVectorInt(aoI, j - 1, k - 1, d);
    int3 c01 = getVectorInt(aoI, j, k - 1, d);
    int3 c02 = getVectorInt(aoI, j + 1, k - 1, d);
    int3 c10 = getVectorInt(aoI, j - 1, k, d);
    int3 c12 = getVectorInt(aoI, j + 1, k, d);
    int3 c20 = getVectorInt(aoI, j - 1, k + 1, d);
    int3 c21 = getVectorInt(aoI, j, k + 1, d);
    int3 c22 = getVectorInt(aoI, j + 1, k + 1, d);

    float v00 = getVoxel(c00);
    float v01 = getVoxel(c01);
    float v02 = getVoxel(c02);
    float v10 = getVoxel(c10);
    float v12 = getVoxel(c12);
    float v20 = getVoxel(c20);
    float v21 = getVoxel(c21);
    float v22 = getVoxel(c22);

    float ao00 = calcAO(v10, v01, v00);
    float ao01 = calcAO(v01, v12, v02);
    float ao11 = calcAO(v12, v21, v22);
    float ao10 = calcAO(v21, v10, v20);

    addQuad(
        getVector(i + 1, j, k, d),
        getVector(i + 1, j + 1, k, d),
        getVector(i + 1, j + 1, k + 1, d),
        getVector(i + 1, j, k + 1, d),
        color,
        ao00,
        ao01,
        ao11,
        ao10,
        front,
        c.x, c.y, c.z,
        normal
    );
}

[numthreads(8, 8, 4)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int i = id.x / 3;
    int j = id.y;
    int k = id.z;
    int d = id.x % 3;

    addQuadIfNeeded(int3(i,j,k), d);    
}