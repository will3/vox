// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

float _HillHeight;
float _PlainHeight;
float4 _RockColor;
float4 _SoilColor;
float4 _WaterColor;
float _MaxHeight;

StructuredBuffer<float4> _RockGradient;
StructuredBuffer<float> _RockGradientIntervals;
float _RockGradientBanding;
int _RockGradientSize;
StructuredBuffer<float> _RockColorNoise;

StructuredBuffer<float> _CanyonBuffer;
StructuredBuffer<float> _HeightBuffer;
StructuredBuffer<float> _RockBuffer;
StructuredBuffer<float> _ScultBuffer;

RWStructuredBuffer<float> _VoxelBuffer;
RWStructuredBuffer<float4> _ColorBuffer;

int _Size;
float3 _Origin;

float4 sampleColor(StructuredBuffer<float4> gradient, StructuredBuffer<float> intervals, int size, float banding, float ratio) {
    if (ratio < 0) {
        ratio = 0;
    }
    if (ratio > 1.0) {
        ratio = 1.0;
    }

    if (banding > 0) {
        ratio = floor(ratio * banding) / banding;
    }

    for (int i = 0; i < size - 1; i++) {
        float ra = intervals[i];
        float rb = intervals[i + 1];

        if (ratio >= ra && ratio <= rb) {
            float r = (ratio - ra) / (rb - ra);
            return lerp(gradient[i], gradient[i + 1], r);
        }
    }

    return float4(0, 0, 0, 0);
}

int getIndex(int3 coord) {
    int dataSize = _Size + 3;
    return (coord.x * dataSize * dataSize) + (coord.y * dataSize) + coord.z;
}

[numthreads(8, 8, 8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int dataSize = _Size + 3;
    if (id.x >= dataSize || id.y >= dataSize || id.z >= dataSize) {
        return;
    }

    int3 coord = int3(id.x, id.y, id.z);
    int index = getIndex(coord);

    float biome = _CanyonBuffer[index];
    float terrainHeight;

    if (biome < -0.1) {
        terrainHeight = _PlainHeight;
    } else if (biome >= -0.1 && biome < 0.1) {
        float ratio = (biome + 0.1) / 0.2;
        terrainHeight = _PlainHeight + (_HillHeight - _PlainHeight) * ratio;
    } else {
        terrainHeight = _HillHeight;
    }

    float absY = coord.y + _Origin.y;
    float gradient = (1.0 - (absY / terrainHeight)) - 0.5;
    float height = _HeightBuffer[index];
    float value = height + gradient;
    float sculpt = _ScultBuffer[index];
    if (sculpt > 0) {
        value -= sculpt;
    }

    float rock = _RockBuffer[index] - gradient * 0.5;

    bool isRock = rock > 0;

    _VoxelBuffer[index] = value;

    float heightRatio = absY / _MaxHeight;
    float colorRatio = heightRatio + _RockColorNoise[index];
    float4 rockColor = sampleColor(_RockGradient, _RockGradientIntervals, _RockGradientSize, _RockGradientBanding, colorRatio);

    _ColorBuffer[index] = rockColor;
}
