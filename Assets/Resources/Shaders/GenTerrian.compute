// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct GenTerrianNoise {
    float height;
    float rockColor;
    float grass;
    float river;
    float stone;
    float stone2;
};

StructuredBuffer<GenTerrianNoise> _NoiseBuffer;

float _HillHeight;
float _PlainHeight;
float _GroundHeight;

float4 _SoilColor;
float4 _WaterColor;
float _MaxHeight;
int _WaterLevel;

// Rock color
StructuredBuffer<float4> _RockGradient;
StructuredBuffer<float> _RockGradientIntervals;
float _RockGradientBanding;
int _RockGradientSize;
StructuredBuffer<float> _HeightValues;
StructuredBuffer<float> _HeightKeys;
int _HeightSize;

// Grass color
StructuredBuffer<float4> _GrassGradient;
StructuredBuffer<float> _GrassGradientIntervals;
float _GrassGradientBanding;
int _GrassGradientSize;

// Grass Normal Filter
StructuredBuffer<float> _GrassNormalValues;
StructuredBuffer<float> _GrassNormalKeys;
int _GrassNormalSize;

// Grass Height Filter
StructuredBuffer<float> _GrassHeightValues;
StructuredBuffer<float> _GrassHeightKeys;
int _GrassHeightSize;

// Grass color
float4 _GrassColor;

float4 _StoneColor;
float _StoneThreshold;

StructuredBuffer<float> _StoneHeightValues;
StructuredBuffer<float> _StoneHeightKeys;
int _StoneHeightSize;

// River
StructuredBuffer<float> _RiverValues;
StructuredBuffer<float> _RiverKeys;
int _RiverSize;

// Output
RWStructuredBuffer<float> _VoxelBuffer;
RWStructuredBuffer<float4> _ColorBuffer;
RWStructuredBuffer<int> _TypeBuffer;

int _Size;
float3 _Origin;
int _DataSize;
int _Resolution;

float Epsilon = 1e-10;

float4 sampleColor(StructuredBuffer<float4> gradient, StructuredBuffer<float> intervals, int size, float banding, float ratio) {
    if (ratio < 0) {
        ratio = 0;
    }
    if (ratio > 1.0) {
        ratio = 1.0;
    }

    if (banding > 0) {
        ratio = floor(ratio * banding) / banding;
    }

    for (int i = 0; i < size - 1; i++) {
        float ra = intervals[i];
        float rb = intervals[i + 1];

        if (ratio >= ra && ratio <= rb) {
            float r = (ratio - ra) / (rb - ra);
            return lerp(gradient[i], gradient[i + 1], r);
        }
    }

    return float4(0, 0, 0, 0);
}

float sampleValue(StructuredBuffer<float> values, StructuredBuffer<float> keys, int size, float ratio) {
    if (ratio < keys[0]) {
        ratio = keys[0];
    }
    if (ratio > keys[size - 1]) {
        ratio = keys[size - 1];
    }

    for (int i = 0; i < size - 1; i++) {
        float ra = keys[i];
        float rb = keys[i + 1];

        if (ratio >= ra && ratio <= rb) {
            float r = (ratio - ra) / (rb - ra);
            float va = values[i];
            float vb = values[i + 1];
            return va + (vb - va) * r;
        }
    }
    return 0;
}

int getIndex(int3 coord) {
    int dataSize = _DataSize;
    return (coord.x * dataSize * dataSize) + (coord.y * dataSize) + coord.z;
}

float readBuffer(StructuredBuffer<float> buffer, int3 coord) {
    int index = coord.x * _DataSize * _DataSize + coord.y * _DataSize + coord.z;
    return buffer[index];
}

float getStone(int3 coord, float heightRatio, GenTerrianNoise noise) {
    int index = getIndex(coord);
    float value = noise.stone + noise.stone2;
    float stoneMultiplier = sampleValue(_StoneHeightValues, _StoneHeightKeys, _StoneHeightSize, heightRatio);
    return value * stoneMultiplier;
    return value;
}

float sampleNoise(StructuredBuffer<float> buffer, int3 coord) {
    float x = coord.x / _Resolution;
    float y = coord.y / _Resolution;
    float z = coord.z / _Resolution;

    int minx = floor(x);
    int miny = float(y);
    int minz = float(z);

    int maxx = minx + 1;
    int maxy = miny + 1;
    int maxz = minz + 1;

    float a = readBuffer(buffer, int3(coord.x, coord.y, coord.z));
    float b = readBuffer(buffer, int3(coord.x + 1, coord.y, coord.z));
    float c = readBuffer(buffer, int3(coord.x, coord.y + 1, coord.z));
    float d = readBuffer(buffer, int3(coord.x + 1, coord.y + 1, coord.z));
    float e = readBuffer(buffer, int3(coord.x, coord.y, coord.z + 1));
    float f = readBuffer(buffer, int3(coord.x + 1, coord.y, coord.z + 1));
    float g = readBuffer(buffer, int3(coord.x, coord.y + 1, coord.z + 1));
    float h = readBuffer(buffer, int3(coord.x + 1, coord.y + 1, coord.z + 1));

    float rx = maxx - x;
    float ry = maxy - y;
    float rz = maxz - z;

    float v = ((a * rx + b * (1 - rx)) * ry + (c * rx + d * (1 - rx)) * (1 - ry)) * rz +
    ((e * rx + f * (1 - rx)) * ry + (g * rx + h * (1 - rx)) * (1 - ry)) * (1 - rz);

    return v;
}

float getVoxel(int3 coord) {
    int index = getIndex(coord);
    float v = _VoxelBuffer[index];
    return v;
}

float getGrassDot(int i, int j, int k) {
    float v = getVoxel(int3(i, j, k));
    if (v <= 0) {
        return 99;
    }

    float v3 = getVoxel(int3(i, j + 1, k));

    if (v3 > 0) {
        return 99;
    }

    float v1 = getVoxel(int3(i + 1, j, k));
    float v2 = getVoxel(int3(i - 1, j, k));
    float v4 = getVoxel(int3(i, j - 1, k));
    float v5 = getVoxel(int3(i, j, k + 1));
    float v6 = getVoxel(int3(i, j, k - 1));

    float3 d =  float3(1, 0, 0) * v1 +
    float3(-1, 0, 0) * v2   +
    float3(0, 1, 0) * v3    +
    float3(0, -1, 0) * v4   +
    float3(0, 0, 1) * v5    +
    float3(0, 0, -1) * v6;
    
    float3 up = float3(0, 1, 0);
    return dot(-normalize(d), up);
}

float getGrass(int3 coord, float heightRatio, int absY, float stone, GenTerrianNoise noise) {
    if (stone > _StoneThreshold) {
        return 0;
    }
    if (absY < _WaterLevel + _GroundHeight) {
        return 0;
    }
    float normal = getGrassDot(coord.x, coord.y, coord.z);
    if (normal == 99) {
        return 0;
    }
    float normalValue = sampleValue(_GrassNormalValues, _GrassNormalKeys, _GrassNormalSize, normal);
    if (normalValue <= 0) {
        return 0;
    }

    float heightValue = sampleValue(_GrassHeightValues, _GrassHeightKeys, _GrassHeightSize, heightRatio);

    if (heightValue <= 0) {
        return 0;
    }

    float grassValue = noise.grass;

    float value = normalValue * heightValue * 1.2 + grassValue;

    if (value <= 0) {
        return 0;
    }

    return value;
}

[numthreads(8, 8, 8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int dataSize = _DataSize;
    if (id.x >= dataSize || id.y >= dataSize || id.z >= dataSize) {
        return;
    }

    int3 coord = int3(id.x, id.y, id.z);
    int index = getIndex(coord);
    GenTerrianNoise noise = _NoiseBuffer[index];
    
    float terrainHeight;

    terrainHeight = _HillHeight;

    float absY = coord.y + _Origin.y;
    float relY = absY - _GroundHeight;

    float gradient = -relY / terrainHeight;
    
    float height = noise.height;
    height = sampleValue(_HeightValues, _HeightKeys, _HeightSize, height);

    float value = height + gradient;
    //value -= riverValue;

    _VoxelBuffer[index] = value;

    float heightRatio = relY / _MaxHeight;
    float colorRatio = heightRatio + noise.rockColor;
    float4 rockColor = sampleColor(_RockGradient, _RockGradientIntervals, _RockGradientSize, _RockGradientBanding, colorRatio);

    int typeAir = 0;
    int typeRock = 1;
    int typeGrass = 2;
    int typeStone = 3;
    int type = typeAir;
    
    float stone = getStone(coord, heightRatio, noise);
    
    // Color
    float grass = getGrass(coord, heightRatio, absY, stone, noise);
    
    if (stone > _StoneThreshold) {
        type = typeStone;
    } else if (grass > 0) {
        type = typeGrass;
    } else {
        type = typeRock;
    }
    _TypeBuffer[index] = type;
    
    if (type == typeStone) {
        _ColorBuffer[index] = _StoneColor;
    } else if (type == typeGrass) {
        float4 grassColor = sampleColor(_GrassGradient, _GrassGradientIntervals, 
            _GrassGradientSize, _GrassGradientBanding, grass);
        _ColorBuffer[index] = grassColor;
    } else if (type == typeRock) {
        _ColorBuffer[index] = rockColor;
    }
}
