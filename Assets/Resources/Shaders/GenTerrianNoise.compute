#pragma kernel CSMain

struct GenTerrianNoise {
    float height;
    float4 rockColor;
    float grass;
    float stone;
    float stone2;
};

float sampleValue(StructuredBuffer<float> values, StructuredBuffer<float> keys, int size, float ratio) {
    if (ratio < keys[0]) {
        ratio = keys[0];
    }
    if (ratio > keys[size - 1]) {
        ratio = keys[size - 1];
    }

    for (int i = 0; i < size - 1; i++) {
        float ra = keys[i];
        float rb = keys[i + 1];

        if (ratio >= ra && ratio <= rb) {
            float r = (ratio - ra) / (rb - ra);
            float va = values[i];
            float vb = values[i + 1];
            return va + (vb - va) * r;
        }
    }
    return 0;
}

StructuredBuffer<float> _HeightBuffer;
StructuredBuffer<float> _RockColorBuffer;
StructuredBuffer<float> _GrassBuffer;
StructuredBuffer<float> _StoneBuffer;
StructuredBuffer<float> _StoneBuffer2;

// Height
float _HeightValues[8];
float _HeightKeys[8];
int _HeightSize;

// Rock color
float4 _RockGradient[8];
float _RockGradientIntervals[8];
float _RockGradientBanding;
int _RockGradientSize;

float3 _Origin;
float _GroundHeight;
float _MaxHeight;

RWStructuredBuffer<GenTerrianNoise> _NoiseBuffer;

int _DataSize;

float4 sampleColor(float4 gradient[8], float intervals[8], int size, float banding, float ratio) {
    return gradient[0];
    if (ratio < 0) {
        ratio = 0;
    }
    if (ratio > 1.0) {
        ratio = 1.0;
    }

    if (banding > 0) {
        ratio = floor(ratio * banding) / banding;
    }

    for (int i = 0; i < size - 1; i++) {
        float ra = intervals[i];
        float rb = intervals[i + 1];

        if (ratio >= ra && ratio <= rb) {
            float r = (ratio - ra) / (rb - ra);
            return lerp(gradient[i], gradient[i + 1], r);
        }
    }

    return float4(0, 0, 0, 0);
}

float sampleValue(float values[8], float keys[8], int size, float ratio) {
    if (ratio < keys[0]) {
        ratio = keys[0];
    }
    if (ratio > keys[size - 1]) {
        ratio = keys[size - 1];
    }

    for (int i = 0; i < size - 1; i++) {
        float ra = keys[i];
        float rb = keys[i + 1];

        if (ratio >= ra && ratio <= rb) {
            float r = (ratio - ra) / (rb - ra);
            float va = values[i];
            float vb = values[i + 1];
            return va + (vb - va) * r;
        }
    }
    return 0;
}

int getIndex(int x, int y, int z) {
    int dataSize = _DataSize;
    return x * dataSize * dataSize + y * dataSize + z;
}

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int dataSize = _DataSize;
    if (id.x >= dataSize || id.y >= dataSize || id.z >= dataSize) {
        return;
    }
    
    int index = getIndex(id.x, id.y, id.z);
    
    int3 coord = int3(id.x, id.y, id.z);
    float absY = coord.y + _Origin.y;
    float relY = absY - _GroundHeight;
    float heightRatio = relY / _MaxHeight;
    float rockColorValue = _RockColorBuffer[index];
    float colorRatio = heightRatio + rockColorValue;
    float4 rockColor = sampleColor(_RockGradient, _RockGradientIntervals, _RockGradientSize, _RockGradientBanding, colorRatio);
    
    GenTerrianNoise t;

    float height = _HeightBuffer[index];
    height = sampleValue(_HeightValues, _HeightKeys, _HeightSize, height);
    t.height = height;
    t.rockColor = rockColor;
    t.grass = _GrassBuffer[index];
    t.stone = _StoneBuffer[index];
    t.stone2 = _StoneBuffer2[index];
    
    _NoiseBuffer[index] = t;
}