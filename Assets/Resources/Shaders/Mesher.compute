// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Triangle {
    float3 a;
    float3 b;
    float3 c;
    float4 colorA;
    float4 colorB;
    float4 colorC;
    int index;
};

int _Size;
StructuredBuffer<float> _VoxelBuffer;
StructuredBuffer<float4> _ColorsBuffer;
AppendStructuredBuffer<Triangle> _TrianglesBuffer;
float _NormalBanding;
int _UseNormals;
int _IsWater;
float _NormalStrength;
float _AoStrength;

int3 getVectorInt(int i, int j, int k, int d) {
    if (d == 0) {
        return int3(i, j, k);
    } else if (d == 1) {
        return int3(k, i, j);
    } 


    return int3(j, k, i);
}

float3 getVector(int i, int j, int k, int d) {
    if (d == 0) {
        return float3(i, j, k);
    } else if (d == 1) {
        return float3(k, i, j);
    } 

    return float3(j, k, i);
}

int getIndex(int3 coord) {
    return coord.x * _Size * _Size + coord.y * _Size + coord.z;
}

float getVoxel(int3 coord) {
    int index = getIndex(coord);
    float v = _VoxelBuffer[index];
    return v;
}

float getDot(int i, int j, int k) {
    float3 v;
    for(int di = -1; di <= 1; di++) {
    for(int dj = -1; dj <= 1; dj++) {
    for(int dk = -1; dk <= 1; dk++) {
        v += normalize(float3(di,dj,dk)) * getVoxel(int3(i + di, j + dj, k + dk));
    }
    }
    }

    // Assume up
    //if (v.x == 0 && v.y == 0 && v.z == 0) {
      //v = float3(0, 1, 0);
    //}

    float3 lightDir = normalize(float3(1, 1, 1));
    float dt = dot(-normalize(v), lightDir);
    dt = clamp(dt, 0.0, 1.0);
    return dt;
}

void addQuad(float3 a, float3 b, float3 c, float3 d, float4 color, float aa, float ab, float ac, float ad, bool order, bool flipped, int index) {
    Triangle t1;
    Triangle t2;

    if (order) {
        t1.a = a;
        t1.b = b;
        t1.c = c;
        t1.colorA = color * aa;
        t1.colorB = color * ab;
        t1.colorC = color * ac;
        t1.index = index;
        _TrianglesBuffer.Append(t1);

        t2.a = a;
        t2.b = c;
        t2.c = d;
        t2.colorA = color * aa;
        t2.colorB = color * ac;
        t2.colorC = color * ad;
        t2.index = index;
        _TrianglesBuffer.Append(t2);
    } else {
        t1.a = c;
        t1.b = b;
        t1.c = a;
        t1.colorA = color * ac;
        t1.colorB = color * ab;
        t1.colorC = color * aa;
        t1.index = index;
        _TrianglesBuffer.Append(t1);

        t2.a = d;
        t2.b = c;
        t2.c = a;
        t2.colorA = color * ad;
        t2.colorB = color * ac;
        t2.colorC = color * aa;
        t2.index = index;
        _TrianglesBuffer.Append(t2);
    }
}

float4 getColor(int3 coord) {
    int index = getIndex(coord);
    return _ColorsBuffer[index];
}

float _getAO(float s1f, float s2f, float cf) {
    bool s1 = s1f > 0;
    bool s2 = s2f > 0;
    bool c = cf > 0;

    if (s1 && s2) {
        return 1.0;
    }

    int count = 0;
    if (s1 > 0) count ++;
    if (s2 > 0) count ++;
    if (c > 0) count ++;

    if (count == 0) return 0.0;
    if (count == 1) return 0.33;
    return 0.66;
}

float getAO(float s1f, float s2f, float cf) {
    return 1.0 - (_getAO(s1f, s2f, cf) * _AoStrength);
}
       
[numthreads(8, 8, 4)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    int i = id.x / 3;
    int j = id.y;
    int k = id.z;
    int d = id.x % 3;

    int size = _Size;

    if (i == 0 || j == 0 || k == 0 ||
        i >= size - 2 || j >= size - 2 || k >= size - 2) {
        return;
    }

    int u = (d + 1) % 3;
    int v = (d + 2) % 3;

    int3 coordA = getVectorInt(i, j, k, d);
    int3 coordB = getVectorInt(i + 1, j, k, d);

    float a = getVoxel(coordA);
    float b = getVoxel(coordB);

    bool front = a > 0;

    if (_IsWater && d != 1 && front) {
        return;
    }

    if (a > 0 == b > 0 )
    {
        return;
    }

    int3 c = front ? int3(i, j, k) : int3(i + 1, j, k);
    c = getVector(c.x, c.y, c.z, d);

    float normal;

    if (_IsWater) {
        normal = 1;
    } else {
        float _normal = getDot(c.x, c.y, c.z);
        if (_NormalBanding != 0.0) {
            _normal = floor(_normal * _NormalBanding) / _NormalBanding;
        }
        normal = 1 - (1 - _normal) * _NormalStrength;
    }
  
    float4 color = getColor(c) * normal;

    int aoI = front ? i + 1 : i;
    int3 c00 = getVectorInt(aoI, j - 1, k - 1, d);
    int3 c01 = getVectorInt(aoI, j, k - 1, d);
    int3 c02 = getVectorInt(aoI, j + 1, k - 1, d);
    int3 c10 = getVectorInt(aoI, j - 1, k, d);
    int3 c12 = getVectorInt(aoI, j + 1, k, d);
    int3 c20 = getVectorInt(aoI, j - 1, k + 1, d);
    int3 c21 = getVectorInt(aoI, j, k + 1, d);
    int3 c22 = getVectorInt(aoI, j + 1, k + 1, d);

    float v00 = getVoxel(c00);
    float v01 = getVoxel(c01);
    float v02 = getVoxel(c02);
    float v10 = getVoxel(c10);
    float v12 = getVoxel(c12);
    float v20 = getVoxel(c20);
    float v21 = getVoxel(c21);
    float v22 = getVoxel(c22);

    float ao00 = getAO(v10, v01, v00);
    float ao01 = getAO(v01, v12, v02);
    float ao11 = getAO(v12, v21, v22);
    float ao10 = getAO(v21, v10, v20);

    bool flipped = ao00 + ao11 > ao01 + ao10;

    int index = getIndex(c);

    addQuad(
        getVector(i + 1, j, k, d),
        getVector(i + 1, j + 1, k, d),
        getVector(i + 1, j + 1, k + 1, d),
        getVector(i + 1, j, k + 1, d),
        color,
        ao00,
        ao01,
        ao11,
        ao10,
        front,
        flipped,
        index
    );
}